After a few million interactions, magic happens, which is that you go from noise to programs. You start to see uh complex programs appear on these tables. This is the most exciting plot that I've made in the last few years, and it's the one that's on the cover of the book. You can see that in the beginning, it's not very computational. And then a sudden transition takes place here. It looks like a phase transition. This is the book that I hear is making the rounds at Sakana, which I'm very happy to hear. The big one on the right, what is intelligence is sort of the Lord of the Rings. And what is life on the left is kind of the Hobbit. So it's kind of the single and it's also chapter one of of what is intelligence. So it goes kind of inside the other one. Mostly what I'll be talking about today is is what's in these two books, but with um with quite a bit more detail, more mathematical detail since I think this is a really good audience for that. And I'll also be connecting it uh a bit with some of the the bigger themes of the A life conference and community and dare I dare I say even movement. You know in particular I actually wanted to begin with this wonderful sort of open problems in artificial life uh summary paper which you know has a number of of very illustrious co-authors uh you know at least one of whom we heard from yesterday and and more than one of whom are are here at the conference. This is uh you know open problems uh 14 open problems in artificial life in the year 2000. How does life arise from the non-living? Uh how do the transition uh to life uh in an artificial chemistry or in silicon environment can occur and why it occurs? I'm sure many of you know this was the the problem that bedeled Darwin. You know he made one of the most uh rich and and uh explanatorily powerful theories in you know ever in science in in discovering how evolution works. But he was unable to explain how evolution got started. Uh he at some point in one of his letters said, you know, you might as well talk about the origin of matter. Um I think that the origin of matter and the origin of life might actually be one and the same thing and evolution might actually be the answer to that question, but it's an evolution that includes uh a term that Darwin did not account for in his original formulation. In section B of these questions, uh determine what is inevitable in the open-ended evolution of life. uh I'm I'm hoping to speak a little bit about that too. Create a formal framework for synthesizing dynamical hierarchies at all scales and develop a theory of information processing, information flow and information generation for evolving systems. Um I won't be going into the information theory in any detail. Um but uh but hopefully we'll we'll set up the problem in in a perhaps somewhat new way that that I I hope will help to do that. Um and finally in section C, how is life related to mind, machines and culture? Um if I have time, I will get into this as well and talk a bit about the emergence of intelligence and mind in an artificial living system and uh the influence of machines on the next major evolutionary transition of life. So uh you know it was really cool to to read this paper from 2020 and to see how much of the perspective uh that that um uh that you had already been exploring then uh you know feels you know right and consistent with uh you know with with a sort of fresh look at this at these problems in 2025. Let me just begin with uh with this question of souls. It used to be in the 19th century and and earlier uh that we thought that uh life had some vital force or spirit that animated it and made it different from inanimate matter. In the 19th century when we began to figure out organic chemistry and be able to synthesize ura and so on u the the idea that that no we should really adopt a strictly materialist perspective because there's nothing special or different about the matter in us versus the matter anywhere else in the universe uh took hold. And that's progress for sure. But um but it also you know when we when we embrace atoms and materialism fully we're left with some uh some questions about you know what differentiates life from non-life then you know like what can we even say about life there are at least some biologists who who say well maybe it's not even meaningful to talk about any difference between life and non-life but I I don't think that that's true uh and I think that the answer to the to the conundrum is to invoke function function is the thing that life has that non-life doesn't have. In other words, if we, you know, just to give you a little parable, if I were to come back from the future with this object and you ask me what it is, uh, and I tell you it is an artificial kidney with a 100red-year lifespan, you can implant it in a body and it'll it'll, you know, it'll work the way your kidneys do. It'll it'll filter ura from the blood and so on. Um, that's a really important piece of information, but it's not a material or a materialist piece of information. It's not something that you could read off from the atoms. uh and you know those atoms could be I don't know tungsten filaments or carbon nano tubes are made out of some technology we don't understand now or it could be organic it could be made out of uh cloned tissue um and and the point is that it working as a kidney doesn't depend on that matter there is a kind of separation of concerns between the matter and the function and so there's some real sense in which the function is like a spirit or like something like something immaterial it's not material and yet it also relies of course on the physics of what's going on you can't have the spirit without the matter as it were. So function is really important and uh and function is something that uh uh you know a rock on a non-living planet uh somewhere doesn't have. You know if you if you break a rock on a non-living planet you now have two rocks. You don't have a broken rock. Uh if you break a kidney you now no longer have a working kidney. That's the difference between something functional and something non-functional. This idea of function was formalized by Alan Turing who never intended the touring machine to actually be built uh when he wrote it in 1936. But there is one that was built by Mike Davyy in 2010. I don't need to review Touring machines with all of you of course um uh you you all know how they how they work. But I do want to review briefly uh Vonoman's update to Turring's thinking about computation uh which which he did a few years later. This was published postumously after Vonoman died. Um but the idea behind behind vonoman's thinking is he was trying to answer the same question that Schroinger had quite had asked in his what is life book. Uh and in particular he was trying to ask the question if you have a robot that is swimming around uh on a uh you know in in a pond and the pond has lots of loose Legos around. There were no I don't know if there were Legos in 1950 but let's pretend there were Legos in 1950. And the job of the robot is to assemble those Legos into a new robot like itself. you know, there's something a little bit mysterious about that. It feels a little bit like pulling yourself up by your own bootstraps or like a paradox. And so he asked, what does it take for something to be able to make something like itself? Uh, which seems uh hard, almost paradoxical. And his conclusion was, well, you need to have instructions for how to make a MI. You need to have a tape with instructions for how to make a MI, and you need to have a universal constructor that will follow the uh the instructions on that on that tape in order to assemble the necessary parts. And you also need to have a tape copier uh so that you can give your offspring uh a copy of that tape. And by the way, the tape has to also include the instructions for making the universal constructor and the tape copier. And if those things all hold, then you have life. You have something that can build itself. Uh and uh what's what's so profound about about Vonoyman's insight? I mean, first of all, he predicted all of this before we knew the structure and function of DNA, before we understood what ribosomes were or had discovered DNA polymerase. So he called it exactly right. Those all of those things really do exist uh inside cells and he figured this out from pure theory never having set foot in a bolab. The the profound insight is that he said by the way a universal constructor is a universal touring machine. Those are literally one and the same thing. And by by making that observation what he discovered was that life is literally embodied computation. It is computational. You cannot have life without having computation. So obviously not everything that is alive reproduces but everything that is alive has to be able to make itself. It has to be able to do some combination of healing, growing, maintaining itself, reproducing. All of that is autopoesis. All of that involves self- construction and all of that necessarily involves a universal constructor. Now what do I mean by embodied computation? This is a really important distinction between vonoyman and touring. in touring the symbols that the that the head writes are different from the head itself and the tape and uh and the table of rules that the that the head follows whereas in vonoyman it's it's more like a 3D printer uh the the memory is atoms not abstract symbols in other words uh you know you could think about a touring machine as like this laptop uh you know which can't extrude another laptop out the side but a vonoyman replicator is like a combination of a laptop and a 3D printer that can print another laptop. So its memory is actually atoms. Uh that's what I mean by embodied. So I don't mean embodied in the ways that a lot of roboticists talk about embodied. I mean that that there is a closure between the uh the medium in which the computation happens and the thing that is actually doing the computation. That's the key. So uh computation that is embodied in that sense and that is autopetic is alive. You can't reproduce non-trivally evolvably without without uh computation. No computation, no life. Uh I do want to say a word briefly about what I mean by computation. Uh and in this I'm following the the work of uh Susan Stephanie, Dominick Horesman, uh Rob Wagner, Viv Kendon. Uh this is from a nice paper they wrote in 2023 relating uh the evolution of a physical system and the computation that it does. So you know on top you have logical gates, on the bottom you have uh you know transistors in in your computer. Uh this is important because you know there's there are no bits in a computer. There are just voltages that go up and down. In fact, you know, even the voltages are an abstraction of something further, you know, if we go further down. But you know the the point is that you have to coarse grain those voltages into bits and then you have to have a logical machine that talks about how those bits uh evolve. What are the what are the what are the computational processes that those bits undergo and there is a mapping from the physical system to the logical system and vice versa. uh when we say something computes what we mean is that it is possible to construct such a mapping and that therefore as the physical system evolves that is equivalent to the logical system evolving. Uh so you know there are some caveats you can have stochcastic computation in which there's a little bit of randomness injected so it doesn't have to be fully deterministic. Uh another really important caveat is that you don't want that description to be infinitely complex. Otherwise, you could have the trivial case of saying like, you know, the water in the sen is a computer and the longer my computation, I just need to make my description longer and longer in order to match. No, that doesn't work either. You need a a kind of alchems razor uh description that uh for it to be valid. But this is a good definition of computation, but it emphasizes that there is something subjective about computation. You need to have a model for how the uh how the physical system translates into the logical system in order for any of this stuff to work. There are implications about entropy, free energy and heat and so on in this model. Uh and in particular uh you as you all know we've talked already you know ectctor Zenil in his very elegant uh talk of a couple of days ago talked about uh and actually Chris Kempus also talked about the landour limit uh and the fact that in a computational system you're constantly reducing the entropy of of your state space and in doing so you therefore require free energy. So uh you know you need need to have free energy available and you need to eject waste heat. The exception in a way only proves the rule which is reversible computation. In reversible computation you generate ancill uh and that's equivalent to just saying there's no exhaust but you know then you either have to keep on making your computer bigger and bigger and bigger as you accumulate these ancill you have to uh shrink what you consider to be the computer and then you're back to reversible to to non-reversible computation once again. three important fallacies that I want to point out before continuing. One of them I will call the Seapolski error. Robert Seapolski you know has written famously about uh people not having free will uh because we're built on physical systems. Uh you know the physics is is uh you know if you like deterministic let's set aside quantum mechanics uh and stuff like this. Let's let's imagine we live in a Newtonian universe. It's fine. It's good enough. The point is that physics is reversible. uh all of the basic physics that we understand uh whether that's you know Newton's equations Maxwell's equations Einstein's equations quantum mechanics all of those are essentially time reversible uh so you can move them either forward or back computation is not reversible when I add you know 3 + 5 to get 8 once I've got the 8 uh and I've you know I haven't kept my ancillates around let's say I no longer know what was added in order to make the eight computation is inherently irreversible and so to say that what true of the physical system is also true of the of the computational system or the logical system is is not is not the case and reversibility would be one trivial example of how that is not the case. Causation by the way only makes sense in the light of irreversibility. All right. So if you have a purely physical system then you know to say that A causes B is equivalent to saying that B causes A because you know everything is kind of a block universe if you like in a uh you know in in that kind of setup. But in computation uh you know you you can you can talk about causality because there are ifs and thens in there. And this once again connects with the way uh you know the way ectctor was talking about how you know essentially nothing in nothing in causation makes sense except in the light of computation. Uh which I fully agree with. Uh another fallacy uh we could call the the early victinstein error. If we say something like birds exist in the world uh line one of the tractatus logical philosophy didn't say birds but whatever. You can't say birds exist or birds don't exist in a way that is independent of a model of the universe. Uh there are no birds in physics. There are no birds in this underlying dynamical system. When we start talking about birds, we already are talking about having some kind of some kind of model. And once we start talking about models, uh you've got causality, reversibility, all kinds of other irreversibility, all kinds of other things in play. And none of these statements are are are airtight. Uh they all rely on on an observer. Uh this is kind of Kant as well I guess. Uh and this leads to the the early linenets error uh or the same error that the good old F good old fashioned AI practitioners had which is that that intelligence could be carried out by by just having a series of uh programs of of sort of strictly logical uh you know deductions or inductions. That doesn't work. This is why good old fashioned AI never never panned out. And and the reason is that that you can't start out with like in math with propositions that are self-sufficient. Even math is not self-sufficient, but let's pretend for a moment and just move from there and kind of do an algebra in order to work various things out. When when your propositions are not airtight and when you're looking only at regularities and patterns, this good oldfashioned uh AI idea simply cannot work. And that's that's why we never got it to work. Let's move now to to some of the artificial life experiments that uh that uh that I began playing with in at the end of 2023 and my team and I published in June of 2024. So just about a year ago. I think some of you uh many of you perhaps have heard of these. They're in the what is life books and I've talked about them a few times. The the basic setup here is to try and get self-replication to get you know abiogenesis the emergence of life from non-life to happen in a purely artificial life system. Uh okay so the setup is to begin with a minimal touring complete language uh I used brain [ __ ] uh because I I really liked the idea of being able to talk at a conference and say brain [ __ ] over and over and I'm fundamentally 12 years old on the inside. Um but but also because it's it's uh it it very closely models uh the touring machine. Uh you know it's it's a it's a a minimal programming language only only eight instructions that uh that looks very touring machineike and moves the head back and forth. I should say that in its original version brain [ __ ] is not embodied computation. It has basically a separate data tape and code tape and that means that it cannot make a copy of itself. So I I made a couple of modifications to brain [ __ ] that actually reduce it from eight instructions to seven in order to make it embodied. Meaning that as it works on the tape, it is able to read its own code and write and write its own code on that tape as well. There's no separate console. There's no separation between the data tape and the uh and the instruction tape. For those of you who are unfamiliar with BrainFuck, there is hello world in it. I'm sure you've already figured out how it works by just looking at the program. Um I actually still haven't, I have to admit. By the way, this is actually the French brain [ __ ] page because I thought it was better uh but translated into English. It's funnier to read it that way. These are these are the eight instructions. You know, the first four are move the head one step to the left, one step to the right, increment the bite at the head, decrement the bite at the head. We're already halfway through. There's an input and output instruction, which in this case really just copy from uh from one head to another. And there are jump instructions, open open bracket and close bracket in order to be able to be able to make loops. Uh and that's it. That's all that's all brain [ __ ] is. So how does how does the uh AIFE experiment work? The AIFE experiment is called BFF. Uh the first BF stand for brain [ __ ] and the second F uh you can draw your own conclusions. Um but uh you start off with with a soup of of uh uh I I actually generally use just 1,000 1,024 tapes. Uh that's enough for this experiment. Uh so the tapes are of fixed length. They're of length 64 and they begin random. So just random bytes. Now, if a tape is random bytes, that means that only one in 32 of them or so are even valid instructions. Most of them are nos. A no-up will just be skipped over uh like in most uh programming languages. So, um so this is what those tapes look like in the beginning. And you can see that, you know, the uh I'm not printing the noops, right? So, that's all the blank space. Uh the the operations are quite sparse. On any given tape, you only have an average of two instructions or so. And then the procedure is to pluck two of these tapes out of the soup at random, concatenate them end to end, so you have 128 bytes, and then run uh and then after running, pull them back apart and put them back in the soup and repeat. That's it. So it's just that over and over. That's the entire experiment. Uh so I'll show you what happens uh on my laptop after a few million interactions. um magic happens which is that you go from noise to to programs. You start to see uh complex programs appear on these tapes. And this is quite wonderful because these programs take uh you know they take real effort to reverse engineer when you when you study them. You know you it's like studying that hello world program. You have to you know they're they're functional in the sense they really do something. Uh and it's not trivial to figure out how they work in order to do that. Uh okay what are they doing? Well, they're definitely copying themselves or each other somehow. We know that because uh if you know this is a histogram and you could see, you know, in this case there were 8,000 tapes, there are 5,000 of the top one, 297 of the next one and so on. So there's clearly copying going on and there's this ecology of programs all copying each other. Uh which is which is just wonderful to see. I mean that's that's that's that you know emergence of of of life in this very functional minimal sense from randomness. A part of this is very easy to understand. You know why why do these things emerge? Well, because something that copies itself will be around forever and something that doesn't copy itself will be copied over by something that can copy itself. So, inherently uh something that can copy itself is more stable than something that cannot copy itself. So, it's really just the second law of thermodynamics but uh but doing something unexpected which is creating something more complex because it's more stable rather than something less complex which is less stable. This idea that stability doesn't necessarily mean uh mean low complexity was worked out in some detail by Adi Pros the organic chemist in another book called what is life. Uh he calls it dynamic kinetic stability. Meaning usually we think of stability only in terms of fixed points in a phase space. But a cycle can be even more stable than a fixed point. Uh of course for these cycles to work you need an input of free energy. Uh but you know for reasons that we've already gone into. Uh okay. So mystery mostly solved but actually mystery not fully solved uh for for reasons that I will that I will uh show in a second. But but just to give you a sense of what of what this transition looks like from non-life to life. It's very dramatic. In the beginning uh you know these interactions uh only involve you know there only a few instructions in the soup. It's a touring gas as Walter Fontano would have called it. When you do the join and you run only two operations run in any given interaction on average uh as as you'd expect. And that's what it looks like by the end in this particular run. Uh and 1,374 operations on average are running per interaction. So the soup has become intensely computational. Uh there's been a transition here. And there's a lot more code uh than than one in 32 uh bytes. As you can see, this is what that looks like visually. This is the most exciting plot that I've made in the last few years. And it's the one that's on the cover of the book. So what I've drawn here are 10 million dots. It's a scatter plot of interactions. The x-axis is time and the y-axis for every dot is how many computations took place. How many operations took place on that interaction and you can see that in the beginning it's not very computational. And then a sudden transition takes place here at at 6 million interactions and it becomes intensely computational. It looks like a phase transition. In fact, it is a phase transition. You can also see that in the the entropy of the soup. So here I'm just ent I'm just estimating the entropy of the soup by zipping it and looking at at the size of the zip relative to the uh to the whole thing. You can use any compression algorithm you like. In the beginning it's uncompressible. So it's a gas you know in that touring gas sense because all the bites are random. And you can see that there's a dramatic change and suddenly it becomes extremely compressible right at that transition moment. And of course this becomes compressible because there everything is copying uh right itself and each other. So if things are copying themselves then they'll we know that they'll become very compressible. But it's cool because if we think about what the phase of matter is on the left, it is just like a gas. Nothing is correlated. What would we call the phase of matter on the right? It's not a liquid. It's not a solid. Right? It has structure. It has structure at every scale. I think you have to call that phase of matter life. Uh that's it's a functional phase of matter. Uh it means that uh that it that its parts are different from its other parts. And if you zoom in or out, you see more structure. So it's what David Walpert would call self dissimilar. It's not a fractal. It's a more like a multiffractal. I'll explain why in a moment. Uh okay. Uh how long does it take this transition to happen? Well um the the answer is it looks more or less like an airline distribution or uh a little bit more precisely like this uh distribution I call a lockpick distribution which imagines that there are steps that have to be undertaken and those steps have a longtail distribution of difficulty. And how many steps does it take? Well, the answer is 12. It takes 12 steps just like uh getting sober. I suppose this is a you know a fit of the empirical to the you know to the heirlong and the lockpick distribution is a little hard to see but the lockpick is a bit better than heirlong. Heirlong assumes pson lockpick assumes longtailed but it's a process phase distribution and and what this tells you is that there are stepping stones here. You know you can't get that transition to life immediately. So something interesting must be going on here on the left other than just randomness. It takes multiple things happening in order to get to that point. You know in this case you know it happens somewhere between 1 million and uh let's say 7 million uh interactions. Okay. So um this all suggests that pretty much any universe by the way that has a source of randomness uh and can support computation uh will evolve life uh you know for this simple dynamical stability reason. But the big mystery is why does why does it appear to get more complex over time? Uh you might have seen in my little video that you know we saw some programs emerge and then we saw the we saw them sort of densify more instructions appeared and and even more fundamentally why does this work even without mutation? I didn't mention but you know in the original version of BFF I added some random mutation because you know we're all taught in school that the way the way evolution works is chance and necessity. you know, you mutate things. You're sort of throwing spaghetti at the wall and whatever sticks is what is what does better. And so you need a source of spaghetti. But if you do this entire experiment with the mutation rate cranked all the way down to zero, you still get the same exact phenomenon. And that is very mysterious because if you crank mutation down to zero, you should have no source of novelty. You should have no evolution. Why do you still get this apparent complexification even with zero mutation? Uh so let's let's go into some of the some of the theory of this. By the end uh we have a replicating entity. It can engage in standard sort of population evolution dynamics. This is the kind of of differential equation that that one generally writes for this sort of thing. It's a very general unsat. Uh this is for you know uh species uh I let's say they're n species. They could be chemical species. They could be biological species whatever. Here's a classic example of of such an ansat. This is the uh the lotka volta equations for predator and prey which I'm sure many of you are very familiar with. They were co-invented or or invented independently by Alfred Lotka and Vto Volatera near the beginning of the 20th century. This is what the classic lota equations look like. There are two species. There is a prey species and a predator species. And those four terms are uh reproduction, getting eaten, uh eating to reproduce and background death rate. So uh if you got those four terms, you get these nice oscillatory solutions uh you know between your predators and your prey that arise. Okay. So this is a slightly more general form of those lotka volta equations. There is a linear part which we'll call rx and uh in lotka volta that linear part is diagonal. Uh so you know the the uh the wolf can't turn into a rabbit, the rabbit can't turn into a wolf. So so the reproduction is diagonal. And then there's also a bilinear term which is the the part where predation, competition and the fact that niches are finite uh gets implemented. So the the the right part is suppressive. The left part makes things grow. The right part makes things uh um squish squish down. Keeps them finite. But this can't be the whole story of evolution. Why can't it be the whole story of evolution? Well, of course, because it's closed-ended. Uh you know, we only have two species here. It doesn't matter how long you run this damn thing. You're not going to get a third species. Uh and uh and you're not going to change the design space either. uh you can have you know very complicated terms in here that allow finch beaks to adapt to different uh environments but you have to have the space of finch beaks predefined before before this uh equation can even be made to work. So uh this doesn't you know this doesn't answer the question of how evolution gets started. It doesn't answer the question of what happens uh afterward other than optimization to uh to niches. So uh now we bring in another uh Eastern European uh Dimmitri Sergeovich Meshovski. So he's the one who first came up with the idea that maybe uh mitochondria engaged in some kind of simogenetic event in order to end up inside other single-c cellled organisms to make um to make ukarots. This was popularized and proven to actually be the case by Lin Margulus uh in in 1968. Uh one of the really great papers in biology from the 20 from the 20th century. uh I'm sure many of you are familiar with this is that paper sorry 1966 on the origin of mitosing cells. So she's the one who proved uh that ukarotes were actually a fusion between two different kinds of procarots and popularized this term that Medishovski had invented symbioenesis. Okay. So could symbioenesis be happening as a as a source of novelty in BFF? Yes, that is the source of novelty in BFF and indeed that is the source of novelty in evolution period. This is something that Lin Margulus believed. Um but uh that was not uh that had not been widely accepted by the by the by the bi biology community even by the time of her death uh in 2011. Um you know so she she had a much more expansive idea about about why symbioenesis was important. Uh only the particulars of chloroplasts and mitochondria had been accepted. So the way we can look for symbioenesis and BFF is to look for replicators emerging before that phase transition. And if you look for them, if you just look for stretches of bytes that are getting copied during those interactions, you find such stretches of bytes. They begin short and kind of crappy, unreliable, but they're there from the beginning. Every time you have a single copy instruction, after all, one bite is getting copied from somewhere to somewhere. So almost by definition, you have at least one bite long sequences that are getting copied right from the beginning. So let's just call them replicators, right? There are replicators there from the beginning. Now if you have these one bite replicators that are copying themselves back and forth now and then once in a while they will come into conjunction and two of them will will copy better as a group than the than the two of them copied on their own and that when that happens then they'll start to copy as a group and that is a symbiogenetic event. uh and and so basically the reason that even without uh mutation you get these complex programs arising is because of these fusion events between smaller replicators. So uh can one build singenesis into an equation like uh like this one that you know for for lot of volta you can this is our statistical physicist who came up with the right kind of term to write mathematically for describing how symbioenesis works. He wrote down an equation for the coagulation of polymers. Uh so this is uh small hovski coagulation. Uh this is what happens when clouds form. It's what happens when gelatin sets in the fridge. Uh so the idea is that you have uh let's say polymers that begin uh as monomers you know one monomer another monomer they they stick together and now you have a dimer and now the dimer and maybe another monomer stick together and you have a trimer. Uh two trimers stick together and now you have a heximer and so on. These are the equations for that. This is the mass balance equation. It's it's very simple. There's a merger gain term and a merger loss term. The merger gain term which scales like the densities of the two things that are coming together. Uh and the product of those with some merger kernel K is increasing the population of cluster K which is of length I plus J. And then you have to do the balance of that. Every time you have two things coming together to make a new one, you have to then subtract their populations I and J. And that's what the right hand side is about. It's the loss of things that have merged. So you put those two things together and you get a stochastic differential equation for mergers in a solution. And by the way there is a phase transition associated with small husky coagulation. It's called gilation. And it's exactly what happens when you put jello in the fridge and it sets. Basically, if things are sticking together and if they stick together with a scaling exponent that is greater than one, then you get this finite time singularity in which the the the things that stick together diverge to infinite size and the whole thing sets no matter how big it is. Uh and that's that's how jello sets. Could that be galation? Yes. Uh the short answer is that is gilation. that phase transition uh that we see of the emergence of life is ailation phase transition according to a generalization of smallhovki coagulation to this case of BFF strings coming together if you if you think about quote unquote inanimate and viral replicators as being replicators that uh that are not self-contained in other words where the code that runs is not fully within the code that is actually getting copied then you you you notice something interesting so what I'm calling here an inanimate replicator uh and very much in scare quotes is uh is code that copies something fully outside itself. In other words, the code that runs in order to do the copying is disjoint from the thing that gets copied. Uh are there such replicators in the real world? Of course, that's what water is, right? Water is a replicator of some kind. It gets made by stuff, but the stuff that it gets uh that it gets made from, you know, like water is not a part of the of the running process. I mean it is a part of the running process that makes more water in some cases but right it's it's it's um it's it's not uh it's not part of the code let's say viral is the case in which the the code and the thing that is copied overlap. So in other words some of the code that does the copying is actually some of the stuff that gets copied but the uh the code is not fully contained by what gets copied. So this is a an an incomplete replicator that would need to cooperate with another replicator in order to reproduce. So that's what I mean by viral. In the beginning of BFF, all of the replicators are inanimate and viral. The great majority are inanimate and a few of them are viral. A few of them happen to copy uh you know one of those uh bites that is actually an instruction that is doing the copying. But as you move toward uh the time of gilation which I've normalized to one here, you can see that cellular replicators suddenly emerge. So they can't emerge before you know about halfway through the run and they and they shoot upward at the end. And that's really interesting because that tells you that that the moment of a cellular replicator where the machinery for copying yourself is part of the thing that is copied emerges through the symbiosis or the symbioenesis of inanimate and viral uh replicators. Okay. So a full equation would have two terms. It would have this reproduction and you know like a voltera type type term and it would have a merger or smallhovsky type term. One on the left is normal population dynamics. That's normal Darwinism. And the one on the right, uh, you could think about the left as evolution and the right as revolution. Right? Those that's the moments when things come together. Now, the population dynamics part for BFF looks like this. It's a little bit more complicated, but it has the same basic form as LKA volta. There's a linear part on the left. I'm just writing that as a matrix uh, RI operating on the on the whole thing. And on the right u the reason that looks a little bit a little bit different from Lka Voltera is that when something gets copied it overwrites other stuff. So uh so now we have to say well how does how does that suppress the populations of everything else in the soup? In order to figure that out you have to look at niches what are the bites where something gets copied and the overlap between the niches of two replicators tells you you know how much one thing getting copied you know how likely it is that that will overwrite uh something else that shares its niche. Uh, okay. The symbioenesis part is a bit of a mess, so I'm not going to go through it. Uh, I hope that's okay. But it looks just like Small Hovsky, just gnarlier. Um, the the reason that it's gnarlier is because Small Hovsky has only binary fusion uh between two parts. And in BFF, sometimes a bunch of things come together. So, you have to take into account these kernels that have more than two uh parameters in them. Also, when things come together, they don't necessarily look like the sum of of the things that came together. You could have something that is three bytes long or something five bytes long come together and the result that copies itself is only two bytes, one bite from each one or or anything uh right along those lines. So to to account for those complexities, you end up with a much more complicated k term, but it's essentially the same as as a small huskulation. to prove that this kind of symbioenesis is needed in order to get uh these complex programs. Uh you you can do a very simple intervention which is uh when you're interacting two tapes you can sort of do it in a sandbox before committing and in the sandbox you see whether uh whether a new replicator arises and if so what replicators is it made out of. In other words, uh you know, when you look at the source, you can see what you know whether whether any of those uh source bytes were actually the output the outputs of copies of some previous replicator. And if so, then you have a tree. You have an ancestry tree for uh for that for that replicator. That means that you can think about the depth of such a tree. Uh you know, how many things have come together and you can limit the depth of that tree. You can say if the tree depth exceeds 10 for a new replicator, then I'm going to I'm going to actually not not do this interaction. and I'm going to take them back apart, pretend it never happened, put it back in the soup, and try again. If you if you limit the depth of the tree to say 24, then the number of operations that you have to block, the number of interactions you have to block is actually very small. You only have to block one in a thousand operations. But that one in a thousand operations is really important. As it turns out, if you block those, no galation will happen. You need uh at least tree depths of 20 or so in order to get these complex uh programs. So this is a very nice proof that symbioenesis is what what is needed in order to get to these complex tapes. When you do that blocking, you end up with sort of logistic curves for the populations of all the replicators in that soup. They they they go up and then they saturate and stabilize. That's fun because it lets you do a little bit of math. So as you can see, you know, that not only do things go up and saturate, but then they they there's some random uh oscillations and those oscillations can be correlated. Sometimes you can see the two of those populations go up and down together. So that means that they they're maybe collaborating with each other and sometimes they go in opposite directions. They're anti-correlated and that means that they're competing with each other because they're you know one is overwriting the other for instance. So that's what one would expect from from off diagonal production and competition from those those equations I wrote earlier. And if you linearize the dynamics around that steady state, then you can sample the correlations in those population fluctuations and you can reconstruct the matrix R. I will skip the details of how one does this, but this is a classic fluctuation analysis. You solve the leaponov equation and you get a Jacobian and from that you get the matrix R. And the matrices R look really cool. First of all, they have a strong diagonal that tells you that by and large things replicate themselves. uh just as you would expect from Lka Voltera. But uh there's some other stuff going on here as well. Aside from that dominant diagonal of self-replication, there is some negative stuff off the diagonal and some positive stuff off the diagonal. The negative stuff off the diagonal, you can see looks largely symmetric about the diagonal. And that's as you would expect too. Basically, if A competes with B, then B competes with A. Two things that are that are fighting for the same niche are are in a kind of zero sum relationship with each other. But the cooperation part where where uh where something helps something else is not symmetric and that's as you would expect too. Just because A helps B or enables B doesn't mean that B enables A or at least not directly. Right? So they're complex cycles in this in this graph on the right of of of codependency or enablement. So uh negative component is symmetric, positive component is is asymmetric and there's this big diagonal. Do the submatrices that are about to undergo symbioenesis have any special properties? They do. So in other words, if it's these let's say four rows and columns that are about to about to undergo symbioenesis, you can ask what are the what are the igen values of that matrix of that submatrix and it turns out that that they are generally cooperative. So essentially if you if you were to pick random rows and columns from this matrix then you get a highdimensional picture of the rank of the matrix. But when you look at the ones that actually combine, it's much lower rank. They're already uh working together. So in other words, there's a relationship between the R and K parts of this equation. Symbioenesis happens among guys who are already working together. Not all the same, not independent, cooperative. Here's another really interesting thing. If you look not at the R matrix but at the Jacobian itself then you can find the signs of imminent instability in it of when it's about to pop when it's about to go run away and gellate uh or gel you don't say gelate you say gel right so in particular if you block the depth of the possible trees to a low number then uh the igen vector the igen values of the jacobian are always negative meaning that the system is stable but as you look at larger depth ceilings you find that more and more of this leading igon vectors or the real parts of those leading igon vectors pop positive and that means that the system is about to blow. Uh you can keep it from blowing for a while by keeping that merger clamp on but it tells you that essentially the more you evolve these things the more they begin to cooperate with each other and the more incipient symbioenesis is about to happen. Uh and that's what leads to this phase transition. Uh, all right. Um, I I just want to put a little plug in for what I think could be a really beautiful missing link between the kind of algorithmic information theory that Ector Zanil was talking about and the assembly theory that he has somewhat slammed with a couple of papers that he has written. But uh, you know, as as those of you who have followed that might know or might might realize from what I've just talked about, there's a very close relationship between what I've just been describing and assembly theory. It's things coming together to make bigger things. But the assembly theory proponents have have not really talked about the computational nature of what they're doing. And in this I fully agree with with where ectctor is coming from. Uh and the way that those connect I think is by starting to look at things like conditional cologoral complexity of the things that are coming together. So I think this is a construction point for us to maybe reconcile those two different pictures. All right. So symbioenesis is what gives you complexification that in turn is what gives evolution its arrow of time. uh in classical evolution and Darwinian evolution there's no reason that things should become more complex over time uh you know they might simplify they might get more complex it doesn't matter but uh with symbioenesis we know that things get more complex because if A can replicate itself and and survive into the future and B can replicate itself and survive into the future when they come together you suddenly need A to replicate itself and B to replicate itself and there's some additional information that has been added which is how the two fit together uh and and those those extra bits of information that keep getting added to the program of what is the large replicator, they don't come from mutation. They come from the fact that things encounter each other randomly in order to possibly undergo that symbiogenetic event. So it's actually the thermal randomness of the fact that we pluck two of these guys out of the soup at random. That's the the information source if you like or the noise source that is selectively turned into algorithmic information by the symbioenetic process. yours and John Mayard Smith have have uh have written you know extensively about these major evolutionary transitions in which symbioenesis results in large novel forms of life like ukarotes multisellularity and so on uh and uh I think this work is great but uh but the flaw is that they're only talking about eight events or 12 events and if if what I'm saying is true then this is just the tip of a gigantic iceberg basically it's symbioenesis all the way down most of these symbioenic events are much more uneven. There may be just a little bit of something getting incorporated into something much bigger, but that is the source of novelty in all of evolution. These are just the most dramatic cases that involve, you know, uh really really big uh visible stuff happening. So, is there evidence for these smaller singogenetic events in biology? Lots there's lots of evidence for it. So uh you know I I don't have time to go into it in any detail but if you look at at just the human genome you find that you know only 1 and a.5% of it codes for our proteins and lots of the rest of it is transposons and uh other endogenous uh retroviral elements of various kinds that involve viruses whose whose ecology is our own genomes and that reproduce inside our genomes and sometimes jump species resulting in weird [ __ ] like uh a quarter of the cow genome being a a retroron that also lives and lizards and salamanders and stuff. Uh, and so, you know, when you start to look at that, you you realize that that genomes are fractal and it's replicators made of replicators made of replicators just as I've as I've described, not these kind of uh, you know, fixed design space and evolution only happening in its usual way. It's not just horizontal gene transfer in bacteria. This synogenetic picture, I think, is is the engine uh, that produces novelty throughout all of life, including including big complex animals like ours, like us. Um there's more and more evidence in the in the last decade of of things like this going on. You know, for instance, the arc virus uh was endogenized uh in in the mammal lineage and you can find it in our brains and it turns out that if you knock out the ark virus in mice, they stop being able to form new memories. So clearly the arc virus is doing something important for us and and that's a source of novelty that that was an endogenized virus. uh similar the mamalian placenta uh was uh is formed by an indogenized virus that fuses cell membranes together and so on. Okay. So there's a definition of life that comes out of this life uh and I I said this uh you know in the panel yesterday is an embodied autopoetic computation arising and complexifying through symbioenesis. It's not just neuroscience that's computational. Life was computational from the beginning and it gets more computationally complex over time through symbioenesis at many scales because remember if life is a computer from the start then every time things fuse together you're making a more and more parallel computer. Those computers have to be not only running the code that model themselves and reproduce themselves but that also do something about modeling the other and figuring out how they interact or work with the other. And this means that an ecology of functions is building up through massively parallel computation that becomes if you like more and more intelligent with every one of these of these fusions. And since symbioenesis makes the computation massively parallel uh that implies that intelligence and life are very very closely connected. uh which is why uh you know I ended up with the book what is life as part of the book what is intelligence when you're not only using that intelligence to model yourself but also to model your environment which by the way includes others most importantly then that's intelligence and that means that life was intelligent from the start and the moment that that modeling of others begins what we call in in larger more complex animals theory of mind becomes fundamental to the way intelligence develops So uh you know these are really simple simulations that show how uh you know just persistence allows you know the modeling of of of an environment to turn into learning chemotaxis in these fake bacteria. Uh but of course you know in real life uh you're not only learning about an environment that that exists in isolation like the like the sugar crystal but actually all of your friends right the moment you're reproducing the greater part of your environment is is actually all of your all of the other things that that uh you know even your own reproduction is creating. Uh life is never single player. Things like intelligence explosions in in our lineage in the hominins and in citations uh and in bats and a variety of other species are exactly this kind of runaway modeling of others resulting in uh growth of brains and growth of of groups and and therefore that you know that when we think about the growth of advanced intelligence you know in in in you know human societies or human brains it's it's really that same sort of of synogenetic process happening at a much at a much higher level. Let's end there and and switch to uh questions. >> I think there are multiple different ways to represent the symbiosis. I think in the real biology we maintain those high record structures and that there are fundamental mathematical differences how how you treat those symbiosis that do you have any insight how we can implement that? Yes, in biology we often uh sort of raify one particular level of detail and we say you know these are the life forms and you know maybe there's a symbiosis between uh you know let's say you know algae and a sea slug but we still think of the algae and the sea slug as as as separate and we think about population dynamics within that rather than modeling them separately. Is there a reason to prefer one scale or another? You know, for me, one of the lessons I the reason that I spent so much time on the relationship between R and K is that you can always move something from one from from R to K and back. Uh, you know, Lin Margulus famously said we're just colonies of bacteria, you know, some of which live inside each other. And that's true. You know, you could describe us as just colonies of bacteria. But the reason that it's useful to to move up a level of detail is because you know humans also you know reproduce as a unit you know hence the mess and uh and there are a lot of things that you can uh you can learn about when you study at that higher level uh a lot of abstractions you can make from a computational perspective that are hard if you're only modeling at the lower level. So I don't think that there's any there's any one layer layer level that is true and we have lots of boundary cases like lyken or like uh colony insects right where you can model the entire colony or you can model the individuals I don't think there's a right answer to those two uh so you know do you do you keep a block of rows and columns in R that are that are uh that are in you know that always end up or mostly end up getting copied together uh or do you add a new row you know it's it's it's actually a coarse graining choice and you can make either one >> symbiosis is not symbiogenesis like you What is the thing that you would claim is kind of like you know a good insight for how like you know A and B stop being A and B in symbiosis and they become something else. the fact that that uh phase transitions don't come from R alone, you know, but but you have to look at K. Now, you you do you do get this these runaway modes, right, which which tell you that something is about to is about to happen. But in order to understand that phase transition, right, in other words, in order to see that a major evolutionary transition has occurred, right, to put it in biological terms, you you actually have to understand the physics of K. It's only by understanding the physics of K that you can do the theory that lets you you know predict and understand what is going on right here. So you know if you model a body as just a bunch of bacteria then it's not wrong but but then uh you know it's invisible to you that uh you know that something amazing happened when we became multisellular or when ukarotes formed out of out of out of bacteria. So this allows higher order modeling and and in particular by the way that higher order modeling you know if we just take the subjective perspective for a moment if you are one of those bodies if you are one of those people then you know you're not going to survive very well if you're only modeling other people as collections of bacteria right you have to build higher order models of them because that becomes an essential part of your envelt and you have to simplify or coar grain the world in order to build a model that is that is ecologically relevant to you so uh you know I'm kind mixing here of of subjective and and an objective perspective. But the subjective perspective ultimately is super important. Uh you know it's a little bit similar to like why do we need temperature and pressure in physics? You know those don't exist if we just look at the microscopics. But it's only by by coarse graining and looking at the larger scale that you can understand thermodynamics. And in the same way, it's only by zooming out and looking at the symbioenesis that you can understand the dynamics of transitions of phase transitions, messes and smaller and coarser grained models that you know where higher orders of things emerge. >> Well, actually that's exactly what I was doing like 30 years ago, right? >> Exactly. That's that's why I began with your nearly 30 years ago paper. There was a big problem like it's always you know the symbol is possible like you know we burn the wood then it becomes complicated coupling with each other however the function itself is not becoming complex or become high water the function itself is just >> I have three answers I suppose uh depending on depending on which way we we talk about it so uh first answer actually comes from from software engineering uh so composition or or from mathematics for for that matter composition of functions is uh symbioenesis as as I've described it and when you compose you know two functions to make a a higher order function you are making something more complex uh than than the than the primitives uh you know and and and you know the what I hinted at with uh you know the Eric Eric Mosnino's you know beginnings of conditional complexity can quantify that sort of compositional complexity you could find signatures of it in you know if you don't want to look in DNA you could look in GitHub at the way you every time somebody writes some code, right? It it begins by importing a bunch of other things and combining them and and and and you you you do see a tendency toward toward complexity. Now that is constrained by energy. Uh you know, the more complex a thing you make, the the the more uh free energy it has to use. But uh now you get uh some of Chris Kempus's beautiful work in which you see that there are energetic benefits to teamwork. Uh right. So, so the the the way the scaling laws work for this uh which are also environmentally dependent. I mean, you know, I don't know Chris if you got to like the snow the snowball earth type stuff, but there were certain very specific conditions at certain points in the earth's history that became favorable for ukarioenesis if I'm remembering correctly and and and so there there are some external conditions as well. But the other cool thing is that when you start to have more uh complexity in the in the computers when you start to have massively parallel computation that greater intelligence also unlocks new energy sources and and that gives you a bigger budget to play with uh which which in turn allows the next me to take place. So I think there's an energetic perspective, there's a compositional perspective, a comorical perspective, there's a scaling law perspective that that can all come to rescue uh that that uh that question, but we should talk more about it. I'd love to I'd love to get into this in more detail. >> It's essential for life to have some functionality pointing for the brain programs their strings in which their functionality by external goals aka the CPU. >> I agree. So I made claims that maybe sound contradictory. You know, one of which was that, you know, Vonoyman is embodied computation and different from touring in that sense, but on the other hand that BFF uh, you know, looks like, you know, very much like a touring machine. And um, and yet I I also said it was embodied because I I made one tape. So you know, even the question of whether something is embodied or not is a little bit perspective dependent as well because in a in a Vonoyman system, for instance, there's of course the same rule operating at every pixel. You know, you can ask yourself the question, is a computer the thing that I make, you know, with lots of parts, right? You know, of the kinds that designed, or is it just the operation of a single pixel? The usual answer is to say what happens at a single pixel is just the physics of that world. But what constitutes the physics and what constitutes the computation is actually a movable boundary. So uh you know embodiment is is is essential in a very minimal sense that you need to be able to uh to operate on the the thing that is going to you need to be able to make coins essentially right in and um uh and in ordinary um uh brain [ __ ] you you can't make a quin because the data tape is separate from the from the program tape but you bring them together you're now in the same realm as as a as a cellular automaton albeit with a different coarse graining of what you consider to be the physics and what you consider to be the the the code. Now I mean in our world we know that it's possible to build computers or else we wouldn't be able to build computers and we wouldn't be here either. Um but you know what constitutes the physics if you like the the physics that makes up computers itself had to evolve. You know we began as I guess nothing but a quant you know quantum field theory and then things came together you know into particles uh you know and the particles come together into atoms the atoms come together into molecules and so on. Those are essentially what I would call the inanimate replicators right in in the system. And and there there's a there's an important phase transition when those suddenly are rich uh form a rich enough set that not only do you have an autoc catalytic system as mold fontana would have said but also that that you can form a touring complete instruction set and and therefore you know open the door to generality of of computing. I hope that I hope that makes uh some sense. >> All right. I think we're >> And yeah, I'm afraid we have to wrap up. So, let's thank once again. >> Thank you so much for this amazing this amazing talk. Great questions, too.
